### Data File Types
- Standard Data Files
- Python Script Files
- Shell Script Files
- (Note: Python Script Files are listed twice in the original, but I'm assuming it's a typo and only listing once here)
- Dos Script Files
- JMeter Script Files
- Other Custom Script Files

### Applicable Scenarios for Data Files

#### Standard Data File Scenarios
- API Functional Testing: Multiple functional points can be maintained at once
- API Exception Value Testing: Multiple exception values can be maintained at once
- API Concurrent Testing: Multiple data points can be executed concurrently
- API Boundary Value Testing: Multiple boundary values can be maintained at once
- API High-Volume Data Testing: Single or multiple data points from the data file can be executed repeatedly
- Business Data Accumulation and Management: Multiple data points can be maintained at once

#### Script File Scenarios
- When system business functions cannot be connected through APIs and require special handling
- Encryption and security-related information, such as keys, require separate handling
- Sensitive information testing for logs
- UI automation for business logic that resides in the frontend
- Environment upgrade management
- Generation of statistical report documents
- Aim: Anything that cannot be achieved with standard data files can be automated through scripts

### Usage of Standard Data Files

#### Composition of Standard Data Files
- Test Case Basic Information: Name, version, associated API ID, whether to run pre-APIs, whether to run post-APIs, whether to run in parallel
- Environment Information: Protocol type, environment IP, unified routing prefix
- API Information: Description, module, application, request method, request route, pre-APIs, post-APIs, provided parameter relationships
- Single-Value Parameter Definition: Defined by the user or automatically generated, select a single item to generate single-value mode
- Multi-Value Parameter Definition: Defined by the user or automatically generated, select multiple items to generate multi-value mode, with a one-to-one correspondence for multiple values within a single field
- Output Parameters: Defined and parsed based on the provided parameter relationships
- Action Definition: Supports pausing, generating CSV/EXCEL bulk data, recording real-time request data as CSV/EXCEL, and recording real-time request data based on file templates
- Assertion Relationships: Defined by the user, supporting checks for empty, not empty, equal, not equal, contains, does not contain, keywords, etc.
- Test Results: Judged based on assertion relationships, PASS if criteria are met, PASS if no assertions are defined and the API request is successful, multiple values and multiple results
- Response Information: Records the information returned by the API, multiple values and multiple responses

#### Header Settings
- Header: Authentication data, request type, etc., such as application/json, form/data, files, etc.
- respHeader: For downloading files, if the filename is generated by the frontend, set Content-Disposition as filename=XXX.filetype, which can be customized based on actual situations.
  Content-Type should be checked according to the API request and filled in accurately. After the request, the response will automatically be set to XXX.filetype, which can then be used for assertion judgments based on file type.
- Example of respHeader:
  ```
  Content-Disposition: attachment; filename=XX模块-XX管理-XX配置-XX导出.csv
  Content-Type: application/csv
  ```
- If the download filename is generated by the backend, directly set assertions based on the returned filename. Assertions can be made using the returned filename.
    - `{type: =, source: raw, value: XX模块-XX管理-XX配置-XX导出.csv}`
    - `{type: =, source: ResponseBody, value: XX模块-XX管理-XX配置-XX导出.csv}`

#### Version Management for Standard Data Files
- Versions are automatically incremented based on historical records. Each time a data file is updated, a backup is made to the historical version directory.

#### Details of Sub-items in Standard Data Files
- [Parameter Application](./parameter_design_en.md)
- [Action Application](./action_design_en.md)
- [Assertion Application](./assert_design_en.md)

#### Authentication Priority for Standard Data Files
- Single File > Environment Configuration, with default environment configuration data. Future expansion: Developed into a separate execution tool, command line parameters > Global Configuration File > Single Configuration File
- If header parameters are defined in a single file but not in the environment configuration, they will be merged into a new header, compatible with file type uploads and downloads.

### Usage of Script Data Files

#### Composition of Script Data Files
- Execution Engine Definition
- Execution Content

#### Details of Script Data File Writing
- [Script Application](./script_design_en.md)

### Reference Examples of Data Files
<details>
<summary>Standard Data File Example</summary>

```yaml
# Case Information
name: Example-UserManagement-CreateUser # Data case name, e.g.: Type-Module-Case, Type: Function/Performance/Exception/Built-in/..., Module: UserManagement/RuleManagement/...
api_id: post_/path        # Case ID, method_path combination, used for data linkage and statistics
version: 1.0              # Data case version, for future data upgrades
is_run_pre_apis: "no"     # Whether to run pre-cases, options: yes / no, default no, feature not developed
is_run_post_apis: "no"    # Whether to run post-cases, options: yes / no, default no, feature not developed
is_parallel: "no"         # Whether to run data in parallel, options: yes / no, default no
is_use_env_config: "yes"  # Whether to use public environment, options: yes / no, default yes

# Environment Information
env:
  protocol: http        # http or https, request protocol
  host: X.X.X.X:8088    # Environment IP or domain name or IP:port
  prepath: /prefix      # Route prefix, common parts can be extracted

# API Basic Information
api:
  description: Create User   # API purpose
  module: UserManagement    # API module
  app: appName           # API application
  method: post           # (Note: ensure correctness) API request method
  path: /path            # (Note: ensure correctness) API request route, no need to write prefix when prepath is extracted or defined in public environment
  pre_apis: []           # When debugging and dependent on pre-cases, related pre-files can be written, feature not fully verified
  param_apis: []         # When debugging and dependent on other case parameters, related files can be written, feature not fully verified
  post_apis: []          # When debugging, test cases to run after completion can be written, feature not fully verified

# Define Single-Value Parameters, if is_use_env_config is "no", define headers here
single:
  header:
    Content-Type: multipart/form-data   # If the API is for file import, set Content-Type to multipart/form-data to override common environment values, optimization level: Data File > App Config > Product Config
  resHeader:
    Content-Disposition: attachment; filename=XXModule-XXManagement-XXConfig-XXExport.csv  # If filename is generated by the frontend, set filename
    Content-Type: application/csv  # Check based on interface requests, fill in according to actuals, after request, response will automatically set to XXX.filetype, then use file type for assertion judgment
  query: {}                             # For GET requests, define request parameters, define only one value, common parameters placed here, no need to repeatedly define
  path: {}                              # PATH variable parameter definition, define only one value
  body:
    condition: '{"children":[{"name":"definitionList","type":"string","value":"{nameList}"}]'  # {nameList} represents variables to be replaced in the string, nameList is the output parameter name in ouput, if there's a same-named variable defined in the pre-case, it will be replaced
    vaLue: '{FlowType}'   # Define parameters under the "System Parameters" menu, supporting multi-language
    name: '*{Name}*'      # Reference the Name variable from above, as a whole, JSON format
    name2: '**{Name}**'   # Reference the Name variable from above, as a whole, string format
    XXName: '{self}'      # Reference the value of the XXName variable from above, [{self} value variables will be gradually deprecated, do not use them anymore, replace existing ones with specific variable names as soon as possible
  bodyList:              # When the request body is directly a List, related request parameters are placed under bodyList
    - name: '{Name}'
      sex: '{Sex}'
    - name: '{Rune(4)}'
      sex: '{Sex}'
# Define Multi-Value Parameters
multi:
  query: {}                   # For GET requests, define request parameters, values defined as lists
  path: {}                    # PATH variable parameter definition, values defined as lists
  body:
    description:              # When defining multiple values, take the minimum number of items defined in each section, corresponding one-to-one
    - '{Rune(128)}'    # Get Chinese characters of a set length
    - '{Str(64)}'      # Get a string of a set length
    - '{Int(10,100)}'  # Get an integer within a set range
    displayName:
    - '{Date(-2)}'      # Get the date two days ago
    - '{Date(2)}'       # Get the date two days later
    - '{Timestamp(-2)}' # Get the timestamp two days ago
    name:
    - '{IDNo}'          # Get an ID card number string
    - '{Name}'          # Get a name string
    - '{Address}'       # Get an address string
    - '{BankNo}'        # Get a bank account number string

# Assertions, data validation, write different types of assertions as needed, if no assertions are written, as long as the return is 200, it is considered PASS
assert:
- type: equal   # Verify that the value of code is equal to 200
  source: code    # Take the value of the key "code" from the returned JSON information
  value: 200 
- type: "!=" # Verify that the value of code is not equal to 200
  source: code    # Take the value of the key "code" from the returned JSON information
  value: 200 
- type: ">="    # Verify that the source field is greater than or equal to 1
  source: data-total     # Take the value of "productDesc" from the "data" dictionary in the returned JSON information
  value: 1
- type: contain
  source: data-contents*productDesc  # Take the value of "productDesc" from the "content" dictionary in the "data" dictionary, and check if it contains the value in "value"
  value: To-be-deleted product description
- type: "!in"   # Verify that the value of "productName" contains "delete"
  source: data-contents*productName  # Take the value of "productName" from the "content" dictionary in the "data" dictionary, not containing the value in "value"
  value: delete
- type: not_contain   # Verify that the value of "productName" does not contain "delete"
  source: data-contents*productName  # Take the value of "productName" from the "content" dictionary in the "data" dictionary
  value: product
- type: re
  source: message
  value: 成功|重复|已存在
- type: re
  source: message
  value: '{successTemplate}'  # Define the assertion value template under the "Assertion Value Template" menu, supporting multiple languages
- type: output  # Extract the value of "uuid" from the returned JSON information and name it uuid
  source: data-contents*uuid
  value: uuid
- type: output  # Extract the value of "uuid" from the returned JSON information and rename it ProductUuid
  source: data-contents*uuid
  value: ProductUuid
- type: output_re  # Extract from the overall return through regular expression matching and rename it taskId, extract the value matched by ()
  source: '\\"taskId\\":\\"(.+)\\"'
  value: taskId
- type: output_re  # Define an output variable, assign the value matched by ([a-zA-Z0-9]+) to taskId, for use by other interfaces
  source: '\\"taskId\\":\\"([a-zA-Z0-9]+)\\"'
  value: taskId
- type: output  # When the return value is a file, take the value in the first row and first column and assign it to taskId
  source: File:TXT:1:1:,
  value: taskId
- type: output  # When the return value is a file, take the value in the first row and first column and assign it to taskId
  source:  File:CSV:1:1:|
  value: taskId
- type: output  # When the return value is a file, take the value in the first row and first column and assign it to taskId
  source:  File:CSV:1:1:|
  value: taskId
- type: output  # When the return value is a file, take the value in the first row and first column and assign it to taskId
  source:  File:EXCEL:1:1
  value: taskId
- type: output  # When the return value is a file, extract the value from the first row, first column of the output file and assign it to taskId  
  source: File:EXCEL:1:1
  value: taskId
- type: output  # When the return value is a file, extract the 'total' value under the 'data' dictionary from the output file and assign it to XXXCount, using the same rule as for standard files  
  source: File:JSON:data-total
  value: XXXCount
- type: output  # Similar to above, but for YAML files  
  source: File:YML:data-total
  value: XXXCount
  
# Actions to perform after data execution  
actions:
  - type: sleep
    value: 1  # Indicates a wait of 1 second, adjustable as needed, in seconds  
  - type: create_csv
    value: name:number  # Generates a CSV file named with the specified format (e.g., filename:number_of_records), defaulting to 10 records  
  - type: create_xls
    value: name:number  # Generates an Excel file named with the specified format, defaulting to 10 records  
  - type: record_csv
    value: name.csv  # Records real-time request body data into a CSV file named 'name.csv', appending if multiple datasets are output to the same file  
  - type: record_xls
    value: name.xls  # Records real-time request body data into an Excel file named 'name.xls', appending if necessary  
  - type: modify_file
    value: name.xml:name_{certid}.xml  # Replaces placeholders in the template file 'name.xml' with actual values from the request (e.g., {certid}), saving as 'name_{certid}.xml'  
  - type: modify_file
    value: name.txt:{phoneno}.txt  # Generates a text file with a unique name based on a placeholder (e.g., {phoneno}), ensuring no data overwriting  
  - type: modify_file
    value: name.json:{phoneno}.json  # Similar to above, but for JSON files  
  - type: modify_file
    value: name.yaml:{phoneno}.yaml  # Similar to above, but for YAML files  
  - type: modify_file
    value: name.yml:{phoneno}.yml  # Similar to above, but for YML files (an alternate YAML file extension)  

# Dependent data output for other interfaces, automatically generated from 'output' type assertions, retrieved using '{self}' or '{uuid}'  
output_dependencies:
  uuid:
    - XXX
    - XXX

# Test results: pass, fail, untest, automatically generated. All assertions met = pass, non-200 response = fail, 0 executions = untest  
test_results:
  - pass
  - fail
  - untest

# Request URLs, automatically generated, retaining the latest test results  
test_urls:
  - http://X.X.X.X:8089/prefix/path

# Request data (body, query), automatically generated, retaining the latest test results  
request_bodies:
  - '{"curPage":"1","endEntryTime":"1627095420000","pageSize":"10","searchOption":"{}","startEntryTime":"1626749820000","timeType":"1"}'

# Response information, automatically generated, retaining the latest test results  
responses:
  - "response1"
  - "response2"
 ```
</details>

<details>
<summary>Python Script File Example</summary>

```---
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# =========================================================================
# FileName: XXX.py
# Creator: XXX
# Mail: XXX@qq.com
# Created Time: 20XX-0X-XX
# Description: Usage desc
# Usage:
# 1. XXX
# 2. XXX
# History:
# 202X-0X-0X/change log
# 202X-0X-0X//change log
#
# Copyright (c) 2024-20XX XXX Tech. All Right Reserved.
# =========================================================================
import argparse
import sys

def functon_something():
    return

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Check and Config OS Env")
    parser.add_argument('-d','--debug', dest="debug", action="store", default='N', help="default value is N")
    args = parser.parse_args()
 
    if args.debug.upper() == "Y":
        DEBUG = True
    else:
        DEBUG = False
    if args.target_host_ip.upper() == "N":
        parser.print_help()
        sys.exit(1)
    handler = functon_something()
 ```
</details>

<details>
<summary>Shell Script File Example</summary>

```---
#!/bin/bash
# =========================================================================
# FileName: XXX.sh
# Creator: XXX
# Mail: XXX@qq.com
# Created Time: 20XX-0X-XX
# Description: Usage desc
# Usage:
# 1. XXX
# 2. XXX
# History:
# 202X-0X-0X/change log 2
# 202X-0X-0X//change log 1
#
# Copyright (c) 2024-20XX XXX Tech. All Right Reserved.
# =========================================================================
HOSTIP="{host}"
TableName="{HiveName}"

function testParameter()
{
    echo $0
    echo $1
    echo $2
    echo "test"
    echo $HOSTIP
    echo $TableName
}

test()
{
   cmd1
   cmd2
   return int
}

# ============================= MAIN ============================================
test
testParameter "paramter1" "parameter2"
```
</details>